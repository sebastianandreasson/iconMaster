{"version":3,"sources":["../../src/query/tabsequence.sort-tabindex.js"],"names":[],"mappings":";;;;;;qBACe,UAAS,QAAQ,EAAE;;;;;;;;;;;;;;;;;AAiBhC,MAAM,GAAG,GAAG,EAAE,CAAC;AACf,MAAM,OAAO,GAAG,EAAE,CAAC;AACnB,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAS,OAAO,EAAE;;;AAG/C,QAAI,OAAO,CAAC,QAAQ,IAAI,CAAC,IAAI,OAAO,CAAC,QAAQ,KAAK,SAAS,EAAE;AAC3D,aAAO,IAAI,CAAC;KACb;;AAED,QAAI,CAAC,GAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;;AAE1B,SAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;;AAE3B,aAAO,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;KAChC;;;AAGD,OAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;;AAEpC,WAAO,KAAK,CAAC;GACd,CAAC,CAAC;;;;;AAKH,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,UAAS,QAAQ,EAAE;AACtD,WAAO,GAAG,CAAC,QAAQ,CAAC,CAAC;GACtB,CAAC,CAAC,WAAW,CAAC,UAAS,QAAQ,EAAE,OAAO,EAAE;AACzC,WAAO,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;GACjC,EAAE,MAAM,CAAC,CAAC;;AAEX,SAAO,SAAS,CAAC;CAClB","file":"tabsequence.sort-tabindex.js","sourcesContent":["\nexport default function(elements) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex\n  // elements with tabIndex \"0\" (including tabbableElements without tabIndex) should be navigated in the order they appear.\n  // elements with a positive tabIndex:\n  //   Elements that have identical tabIndexes should be navigated in the order they appear.\n  //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.\n\n  // NOTE: sort implementation may be unstable and thus mess up DOM order,\n  // that's why we build a map that's being sorted instead. If we were able to rely\n  // on a stable sorting algorithm, sortTabindex() could be as simple as\n  // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });\n  // at this time Chrome does not use a stable sorting algorithm\n  // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability\n\n  // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition\n\n  const map = {};\n  const indexes = [];\n  const normal = elements.filter(function(element) {\n    // extract elements that don't need sorting\n    // in Trident and Gecko SVGElement does not know about the tabIndex property\n    if (element.tabIndex <= 0 || element.tabIndex === undefined) {\n      return true;\n    }\n\n    if (!map[element.tabIndex]) {\n      // create sortable bucket for dom-order-preservation of elements with the same tabIndex\n      map[element.tabIndex] = [];\n      // maintain a list of unique tabIndexes\n      indexes.push(element.tabIndex);\n    }\n\n    // sort element into the proper bucket\n    map[element.tabIndex].push(element);\n    // element moved to sorting map, so not \"normal\" anymore\n    return false;\n  });\n\n  // sort the tabindex ascending,\n  // then resolve them to their appropriate buckets,\n  // then flatten the array of arrays to an array\n  const _elements = indexes.sort().map(function(tabIndex) {\n    return map[tabIndex];\n  }).reduceRight(function(previous, current) {\n    return current.concat(previous);\n  }, normal);\n\n  return _elements;\n}\n"]}