{"version":3,"sources":["../../src/fix/pointer-focus-children.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA,MAAI,MAAM,YAAA,CAAC;AACX,MAAI,SAAS,YAAA,CAAC;;AAEd,MAAM,wBAAwB,GAAG,sBAAS,IAAI,KAAK,IAAI,IAAK,sBAAS,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,AAAC,CAAC;;AAElG,MAAM,SAAS,GAAG,OAAO,QAAQ,KAAK,WAAW,KAAK,eAAe,IAAI,QAAQ,GAAG,aAAa,GAAG,eAAe,CAAA,AAAC,CAAC;;AAErH,MAAI,CAAC,wBAAwB,EAAE;AAC7B,UAAM,GAAG,YAAW,EAAE,CAAC;GACxB,MAAM;;AACL,UAAM,sBAAsB,GAAG,SAAzB,sBAAsB,CAAY,KAAK,EAAE;;AAE7C,YAAM,MAAM,GAAG,iCAAe,EAAC,OAAO,EAAE,KAAK,CAAC,MAAM,EAAC,CAAC,CAAC;AACvD,YAAI,CAAC,MAAM,IAAI,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE;;AAEtC,iBAAO;SACR;;;AAGD,YAAM,OAAO,GAAG,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;;AAElF,YAAI,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;AAClC,iBAAO;SACR;;;;;;;AAOD,YAAM,OAAO,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAS,OAAO,EAAE;AAC7D,cAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,UAAU,IAAI,EAAE,CAAC;AAClD,cAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,UAAU,IAAI,EAAE,CAAC;AAClD,iBAAO,CAAC,KAAK,CAAC,UAAU,GAAG,QAAQ,CAAC;AACpC,iBAAO,CAAC,KAAK,CAAC,UAAU,GAAG,MAAM,CAAC;AAClC,iBAAO,CAAC,OAAO,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;SAC1C,CAAC,CAAC;;;AAGH,cAAM,CAAC,YAAY,CAAC,YAAW;AAC7B,iBAAO,CAAC,OAAO,CAAC,UAAS,IAAI,EAAE;AAC7B,gBAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AACnC,gBAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;WACpC,CAAC,CAAC;SACJ,CAAC,CAAC;OACJ,CAAC;;AAEF,YAAM,GAAG,UAAS,OAAO,EAAE;AACzB,eAAO,CAAC,gBAAgB,CAAC,SAAS,EAAE,sBAAsB,EAAE,IAAI,CAAC,CAAC;OACnE,CAAC;;AAEF,eAAS,GAAG,UAAS,OAAO,EAAE;AAC5B,eAAO,CAAC,mBAAmB,CAAC,SAAS,EAAE,sBAAsB,EAAE,IAAI,CAAC,CAAC;OACtE,CAAC;;GACH;;mBAEc,iCAAgB,EAAE,MAAM,EAAN,MAAM,EAAE,SAAS,EAAT,SAAS,EAAE,CAAC","file":"pointer-focus-children.js","sourcesContent":["/*\n  Children of focusable elements with display:flex are focusable.\n  Because focus can be given to focusable (not tabbable) elements\n  by mouse, we have to counter this behavior, so the correct element\n  becomes the activeElement (i.e. receives focus).\n\n  Example:\n    <div tabindex=\"-1\" style=\"display:flex\">\n      <span>I would receive focus</span>\n    </div>\n\n  This (wrong) behavior was observed in Internet Explorer 10 and 11.\n  It is fixed in IE12 (Win10 IE Tec Preview)\n*/\n\nimport platform from 'platform';\nimport getFocusTarget from '../get/focus-target';\nimport decorateContext from '../util/decorate-context';\n\nlet engage;\nlet disengage;\n// This fix is only relevant to IE10 (Trident/6) and IE11 (Trident/7)\nconst relevantToCurrentBrowser = platform.name === 'IE' && (platform.version.match(/^(10|11)\\./));\n// IE10 requires prefix, IE11 does not\nconst eventName = typeof document !== 'undefined' && ('onpointerdown' in document ? 'pointerdown' : 'MSPointerDown');\n\nif (!relevantToCurrentBrowser) {\n  engage = function() {};\n} else {\n  const handleBeforeFocusEvent = function(event) {\n    // find the element that would receive focus\n    const target = getFocusTarget({context: event.target});\n    if (!target || target === event.target) {\n      // there's nothing to focus, or we're focusing the element clicked on\n      return;\n    }\n\n    // if the focus target does not have display:flex we're good\n    const display = window.getComputedStyle(target, null).getPropertyValue('display');\n    // flex, flexbox, -ms-flex, inline-flexbox (yeah, whateverâ€¦)\n    if (display.indexOf('flex') === -1) {\n      return;\n    }\n\n    // hide all children, because hidden elements can't get focus\n    // remember previous element style (not necessarily computed style)\n    // to undo hiding later. Reset transitions as well, in case visibility\n    // is to be transitioned. This will effectively kill all transitions\n    // that are executed on mousedown / :active\n    const reverse = [].map.call(target.children, function(element) {\n      const visibility = element.style.visibility || '';\n      const transition = element.style.transition || '';\n      element.style.visibility = 'hidden';\n      element.style.transition = 'none';\n      return [element, visibility, transition];\n    });\n\n    // add cleanup (undo hide) to the RunLoop\n    window.setImmediate(function() {\n      reverse.forEach(function(item) {\n        item[0].style.visibility = item[1];\n        item[0].style.transition = item[2];\n      });\n    });\n  };\n\n  engage = function(element) {\n    element.addEventListener(eventName, handleBeforeFocusEvent, true);\n  };\n\n  disengage = function(element) {\n    element.removeEventListener(eventName, handleBeforeFocusEvent, true);\n  };\n}\n\nexport default decorateContext({ engage, disengage });\n"]}