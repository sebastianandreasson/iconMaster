{"version":3,"sources":["../../src/when/key.binding.js"],"names":[],"mappings":"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","file":"key.binding.js","sourcesContent":["\n/*\n  decodes a key binding token to a JavaScript structure\n\n  returns an array of objects:\n    {\n      // key name translated to keyCode (possibly more than one)\n      keyCodes: [<number>],\n      // translated modifiers\n      modifiers: {\n        altKey: null,   // ignore\n        ctrKey: false,  // expect not pressed\n        metaKey: true,  // expect pressed\n        shiftKey: true, // expect pressed\n      },\n      // callback that returns true if event's\n      // modifier keys match the expected state\n      matchModifiers: function(event){},\n    }\n*/\n\nimport keycode from '../map/keycode';\n\nconst modifier = {\n  alt: 'altKey',\n  ctrl: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey',\n};\n\nconst modifierSequence = Object.keys(modifier).map(name => modifier[name]);\n\nfunction createExpectedModifiers(ignoreModifiers) {\n  const value = ignoreModifiers ? null : false;\n  return {\n    altKey: value,\n    ctrlKey: value,\n    metaKey: value,\n    shiftKey: value,\n  };\n}\n\nfunction resolveModifiers(modifiers) {\n  const ignoreModifiers = modifiers.indexOf('*') !== -1;\n  const expected = createExpectedModifiers(ignoreModifiers);\n\n  modifiers.forEach(function(token) {\n    if (token === '*') {\n      // we've already covered the all-in operator\n      return;\n    }\n\n    // we want the modifier pressed\n    let value = true;\n    const operator = token.slice(0, 1);\n    if (operator === '?') {\n      // we don't care if the modifier is pressed\n      value = null;\n    } else if (operator === '!') {\n      // we do not want the modifier pressed\n      value = false;\n    }\n\n    if (value !== true) {\n      // compensate for the modifier's operator\n      token = token.slice(1);\n    }\n\n    const propertyName = modifier[token];\n    if (!propertyName) {\n      throw new TypeError('Unknown modifier \"' + token + '\"');\n    }\n\n    expected[propertyName] = value;\n  });\n\n  return expected;\n}\n\nfunction resolveKey(key) {\n  const code = keycode[key] || parseInt(key, 10);\n  if (!code || typeof code !== 'number' || isNaN(code)) {\n    throw new TypeError('Unknown key \"' + key + '\"');\n  }\n\n  return [code].concat(keycode._alias[code] || []);\n}\n\nfunction matchModifiers(expected, event) {\n  // returns true on match\n  return !modifierSequence.some(function(prop) {\n    // returns true on mismatch\n    return typeof expected[prop] === 'boolean' && Boolean(event[prop]) !== expected[prop];\n  });\n}\n\nexport default function(text) {\n  return text.split(/\\s+/).map(function(_text) {\n    const tokens = _text.split('+');\n    const _modifiers = resolveModifiers(tokens.slice(0, -1));\n    const _keyCodes = resolveKey(tokens.slice(-1));\n    return {\n      keyCodes: _keyCodes,\n      modifiers: _modifiers,\n      matchModifiers: matchModifiers.bind(null, _modifiers),\n    };\n  });\n}\n"]}