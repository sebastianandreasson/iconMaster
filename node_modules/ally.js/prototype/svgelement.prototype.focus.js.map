{"version":3,"sources":["../../src/prototype/svgelement.prototype.focus.js"],"names":[],"mappings":";;;;;;;;;;;;;;;qBAUwB,QAAQ;;AAAjB,SAAS,QAAQ,CAAC,IAAI,EAAE;AACrC,MAAI,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,EAAE;AACnC,WAAO;GACR;;;AAGD,MAAM,qBAAqB,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;;AAE1D,MAAI;;AAEF,QAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;AAC7C,KAAC,CAAC,SAAS,GAAG,2FAA2F,CAAC;AAC1G,QAAM,CAAC,GAAG,CAAC,CAAC,iBAAiB,CAAC;AAC9B,QAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;AAEjC,QAAI,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC;AACnE,QAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC;GAClE,CAAC,OAAM,CAAC,EAAE;AACT,QAAI,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,GAAG,SAAS,aAAa,GAAG;;AAEzD,UAAI,CAAC,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,iCAAiC,CAAC,CAAC;KACtG,CAAC;AACF,QAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,GAAG,SAAS,YAAY,GAAG;;AAEvD,YAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,gCAAgC,CAAC,CAAC;KAChG,CAAC;GACH;;;AAGD,MAAI,CAAC,QAAQ,CAAC,aAAa,IAAI,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;AAClE,uBAAqB,IAAI,qBAAqB,CAAC,KAAK,EAAE,CAAC;CACxD;;AAED,OAAO,MAAM,KAAK,WAAW,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC","file":"svgelement.prototype.focus.js","sourcesContent":["\n// Firefox and IE11 do not \"properly\" inherit the focus() method.\n// That may be because SVGElement inherits from Element and focus() is defined on HTMLElement.\n// WebKit and Blink - probably by accident - defined focus() on Element, which is why focusing SVGElements works fine.\n\n// Firefox' focus() implementation validates the execution context, it demands being called on instances of HTMLElement,\n// which is why simply copying HTMLElement's focus over to SVGElement ends in the following exception:\n// TypeError: 'focus' called on an object that does not implement interface HTMLElement.\n// this works fine in IE11, though.\n\nexport default function polyfill(root) {\n  if (root.SVGElement.prototype.focus) {\n    return;\n  }\n\n  // remember what had focus to restore after test\n  const previousActiveElement = root.document.activeElement;\n\n  try {\n    // create a dummy <svg> so we can check if HTMLElement's focus() can deal with it\n    const d = root.document.createElement('div');\n    d.innerHTML = '<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\"></svg>';\n    const s = d.firstElementChild;\n    root.document.body.focus.call(s);\n    // HTMLElement's focus() can also deal with SVGElement, so go crazy!\n    root.SVGElement.prototype.focus = root.HTMLElement.prototype.focus;\n    root.SVGElement.prototype.blur = root.HTMLElement.prototype.blur;\n  } catch(e) {\n    root.SVGElement.prototype.focus = function focusPolyfill() {\n      // at least make apparent what is going wrong\n      root.window.console && window.console.warn && window.console.warn('SVGElement.focus() not possible');\n    };\n    root.SVGElement.prototype.blur = function blurPolyfill() {\n      // at least make apparent what is going wrong\n      window.console && window.console.warn && window.console.warn('SVGElement.blur() not possible');\n    };\n  }\n\n  // restore focus to what it was before test and cleanup\n  root.document.activeElement && root.document.activeElement.blur();\n  previousActiveElement && previousActiveElement.focus();\n}\n\ntypeof window !== 'undefined' && polyfill(window);\n"]}