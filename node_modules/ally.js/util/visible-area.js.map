{"version":3,"sources":["../../src/util/visible-area.js"],"names":[],"mappings":"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","file":"visible-area.js","sourcesContent":["\nimport getParents from '../get/parents';\n\nfunction getIntersectingRect(one, two) {\n  // identify the rectangle that _element and _container overlap in\n  const top = Math.max(one.top, two.top);\n  const left = Math.max(one.left, two.left);\n  // make sure bottom can't be above top, right can't be before left\n  const right = Math.max(Math.min(one.right, two.right), left);\n  const bottom = Math.max(Math.min(one.bottom, two.bottom), top);\n  // return something resembling ClientRect\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    width: right - left,\n    height: bottom - top,\n  };\n}\n\nfunction getViewportRect() {\n  const width = window.innerWidth || document.documentElement.clientWidth;\n  const height = window.innerHeight || document.documentElement.clientHeight;\n  // return something resembling ClientRect\n  return {\n    top: 0,\n    right: width,\n    bottom: height,\n    left: 0,\n    width: width,\n    height: height,\n  };\n}\n\nfunction getInnerBoundingClientRect(element) {\n  // convenience for the .reduce() in getScrollableParentRect()\n  const rect = element.getBoundingClientRect();\n\n  // remove the width of the scrollbar because that\n  // area is not really considered visible\n  // NOTE: assuming scrollbar is always to the right and bottom\n  const scrollbarWidth = element.offsetWidth - element.clientWidth;\n  const scrollbarHeight = element.offsetHeight - element.clientHeight;\n  // cannot mutate rect because it has readonly properties\n  const _rect = {\n    top: rect.top,\n    left: rect.left,\n    right: rect.right - scrollbarWidth,\n    bottom: rect.bottom - scrollbarHeight,\n    width: rect.width - scrollbarWidth,\n    height: rect.height - scrollbarHeight,\n    area: 0,\n  };\n\n  _rect.area = _rect.width * _rect.height;\n  return _rect;\n}\n\nfunction isOverflowingElement(element) {\n  const style = window.getComputedStyle(element, null);\n  const value = 'visible';\n  return style.getPropertyValue('overflow-x') !== value\n    && style.getPropertyValue('overflow-y') !== value;\n}\n\nfunction isScrollableElement(element) {\n  // an element not scrollable if it doesn't crop its content\n  if (!isOverflowingElement(element)) {\n    return false;\n  }\n\n  // an element is scrollable when it is smaller than its content\n  return element.offsetHeight < element.scrollHeight\n    || element.offsetWidth < element.scrollWidth;\n}\n\nfunction getScrollableParentRect(element) {\n  // get largest possible space constrained by scrolling containers\n\n  // find scrollable parents\n  const scrollingContainers = getParents({context: element}).slice(1).filter(isScrollableElement);\n\n  if (!scrollingContainers.length) {\n    // no containers, no joy\n    return null;\n  }\n\n  // identify the currently visible intersection of all scrolling container parents\n  return scrollingContainers.reduce(function(previous, current) {\n    const rect = getInnerBoundingClientRect(current);\n    const intersection = getIntersectingRect(rect, previous);\n    // identify the smallest scrolling container so we know how much space\n    // our element can fill at the most - note that this is NOT the area\n    // of the intersection, intersection is just abused as a vehicle\n    intersection.area = Math.min(rect.area, previous.area);\n    return intersection;\n  }, getInnerBoundingClientRect(scrollingContainers[0]));\n}\n\nexport default function(element) {\n  // dimensions of the element itself\n  const _element = element.getBoundingClientRect();\n  // dimensions of the viewport\n  const _viewport = getViewportRect();\n  // we need the area to know how much of the element can be displayed at the most\n  _viewport.area = _viewport.width * _viewport.height;\n\n  let _area = _viewport;\n  // dimensions of the intersection of all scrollable parents\n  const _container = getScrollableParentRect(element);\n  if (_container) {\n    if (!_container.width || !_container.height) {\n      // scrollable containers without dimensions are invisible,\n      // meaning that the element is not visible at all\n      return 0;\n    }\n\n    // dimension the element can currently be rendered in\n    _area = getIntersectingRect(_container, _viewport);\n    _area.area = _container.area;\n  }\n\n  // dimension of the element currently rendered in identified space\n  const _visible = getIntersectingRect(_element, _area);\n  if (!_visible.width || !_visible.height) {\n    // element is not shown within the identified area\n    return 0;\n  }\n\n  // compare the element's currently visible size to the size it\n  // could take up at the most, being either the element's actual\n  // size, or the space theroetically made available if all\n  // scrollable parents are aligned properly\n  const area = _element.width * _element.height;\n  const maxArea = Math.min(area, _area.area);\n  // Firefox may return sub-pixel bounding client rect\n  return Math.round(_visible.width) * Math.round(_visible.height) / maxArea;\n}\n"]}