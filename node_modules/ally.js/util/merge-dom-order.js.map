{"version":3,"sources":["../../src/util/merge-dom-order.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;yBAoBsB,cAAc;;;;4BACX,kBAAkB;;;;AAE3C,SAAS,uBAAuB,CAAC,IAAI,EAAE,MAAM,EAAE;;AAE7C,SAAO,IAAI,CAAC,SAAS,CAAC,UAAS,OAAO,EAAE;AACtC,WAAO,MAAM,CAAC,uBAAuB,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,2BAA2B,CAAC;GACnF,CAAC,CAAC;CACJ;;AAED,SAAS,oBAAoB,CAAC,IAAI,EAAE,QAAQ,EAAE,cAAc,EAAE;;;AAG5D,MAAM,UAAU,GAAG,EAAE,CAAC;AACtB,UAAQ,CAAC,OAAO,CAAC,UAAS,OAAO,EAAE;AACjC,QAAI,OAAO,GAAG,IAAI,CAAC;AACnB,QAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;;AAEnC,QAAI,MAAM,KAAK,CAAC,CAAC,EAAE;;AAEjB,YAAM,GAAG,uBAAuB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AAChD,aAAO,GAAG,KAAK,CAAC;KACjB;;AAED,QAAI,MAAM,KAAK,CAAC,CAAC,EAAE;;;AAGjB,YAAM,GAAG,IAAI,CAAC,MAAM,CAAC;KACtB;;;AAGD,QAAM,UAAU,GAAG,4BAAU,cAAc,GAAG,cAAc,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AACjF,QAAI,CAAC,UAAU,CAAC,MAAM,EAAE;;AAEtB,aAAO;KACR;;AAED,cAAU,CAAC,IAAI,CAAC;AACd,YAAM,EAAN,MAAM;AACN,aAAO,EAAP,OAAO;AACP,cAAQ,EAAE,UAAU;KACrB,CAAC,CAAC;GACJ,CAAC,CAAC;;AAEH,SAAO,UAAU,CAAC;CACnB;;AAED,SAAS,uBAAuB,CAAC,IAAI,EAAE,UAAU,EAAE;;;AAGjD,MAAI,QAAQ,GAAG,CAAC,CAAC;;;AAGjB,YAAU,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;WAAK,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM;GAAA,CAAC,CAAC;AAC/C,YAAU,CAAC,OAAO,CAAC,UAAS,SAAS,EAAE;;AAErC,QAAM,MAAM,GAAG,SAAS,CAAC,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;AACzC,QAAM,IAAI,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG,QAAQ,EAAE,MAAM,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;AAC9E,QAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC9B,YAAQ,IAAI,SAAS,CAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAC;GAChD,CAAC,CAAC;CACJ;;qBAEc,YAAgD;mEAAJ,EAAE;;MAApC,IAAI,QAAJ,IAAI;MAAE,QAAQ,QAAR,QAAQ;MAAE,cAAc,QAAd,cAAc;;;AAErD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;;AAE5B,MAAM,SAAS,GAAG,4BAAU,QAAQ,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAC/C,iCAAa,SAAS,CAAC,CAAC;;;AAGxB,MAAM,UAAU,GAAG,oBAAoB,CAAC,KAAK,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;;AAE1E,yBAAuB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AAC3C,SAAO,KAAK,CAAC;CACd","file":"merge-dom-order.js","sourcesContent":["\n// sort a list of elements into another list of elements in DOM order\n\n/*\n  USAGE:\n    mergeDomOrder({\n      // DOM ordered array of elements to use as base of merge\n      list: [],\n      // unordered array of elements to merge into base list\n      elements: [],\n      // callback function to resolve an element\n      resolveElement: function(element) {\n        // return null to skip\n        // return element to replace insertion\n        // return [element1, element2, â€¦] to replace insertion with multiple elements\n        return element;\n      },\n    })\n*/\n\nimport nodeArray from './node-array';\nimport sortDomOrder from './sort-dom-order';\n\nfunction getFirstSuccessorOffset(list, target) {\n  // find the first element that comes AFTER the target element\n  return list.findIndex(function(element) {\n    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;\n  });\n}\n\nfunction findInsertionOffsets(list, elements, resolveElement) {\n  // instead of mutating the elements list directly, remember position and map\n  // to inject later, when we can do this more efficiently\n  const insertions = [];\n  elements.forEach(function(element) {\n    let replace = true;\n    let offset = list.indexOf(element);\n\n    if (offset === -1) {\n      // element is not in target list\n      offset = getFirstSuccessorOffset(list, element);\n      replace = false;\n    }\n\n    if (offset === -1) {\n      // there is no successor in the tabsequence,\n      // meaning the image must be the last element\n      offset = list.length;\n    }\n\n    // allow the consumer to replace the injected element\n    const injections = nodeArray(resolveElement ? resolveElement(element) : element);\n    if (!injections.length) {\n      // we can't inject zero elements\n      return;\n    }\n\n    insertions.push({\n      offset,\n      replace,\n      elements: injections,\n    });\n  });\n\n  return insertions;\n}\n\nfunction insertElementsAtOffsets(list, insertions) {\n  // remember the number of elements we have already injected\n  // so we account for the caused index offset\n  let inserted = 0;\n  // make sure that we insert the elements in sequence,\n  // otherwise the offset compensation won't work\n  insertions.sort((a, b) => a.offset - b.offset);\n  insertions.forEach(function(insertion) {\n    // array.splice has an annoying function signature :(\n    const remove = insertion.replace ? 1 : 0;\n    const args = [insertion.offset + inserted, remove].concat(insertion.elements);\n    list.splice.apply(list, args);\n    inserted += insertion.elements.length - remove;\n  });\n}\n\nexport default function({list, elements, resolveElement} = {}) {\n  // operate on a copy so we don't mutate the original array\n  const _list = list.slice(0);\n  // make sure the elements we're injecting are provided in DOM order\n  const _elements = nodeArray(elements).slice(0);\n  sortDomOrder(_elements);\n  // find the offsets within the target array (list) at which to inject\n  // each individual element (from elements)\n  const insertions = findInsertionOffsets(_list, _elements, resolveElement);\n  // actually inject the elements into the target array at the identified positions\n  insertElementsAtOffsets(_list, insertions);\n  return _list;\n}\n"]}